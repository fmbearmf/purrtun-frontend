{
  "resolvedId": "/home/bear/.app/purrtun-frontend/node_modules/.pnpm/@unhead+shared@1.9.4/node_modules/@unhead/shared/dist/index.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "function asArray$1(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst SelfClosingTags = [\"meta\", \"link\", \"base\"];\nconst TagsWithInnerContent = [\"title\", \"titleTemplate\", \"script\", \"style\", \"noscript\"];\nconst HasElementTags = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst ValidHeadTags = [\n  \"title\",\n  \"titleTemplate\",\n  \"templateParams\",\n  \"base\",\n  \"htmlAttrs\",\n  \"bodyAttrs\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst UniqueTags = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\", \"templateParams\"];\nconst TagConfigKeys = [\"tagPosition\", \"tagPriority\", \"tagDuplicateStrategy\", \"children\", \"innerHTML\", \"textContent\", \"processTemplateParams\"];\nconst IsBrowser = typeof window !== \"undefined\";\nconst composableNames = [\n  \"getActiveHead\",\n  \"useHead\",\n  \"useSeoMeta\",\n  \"useHeadSafe\",\n  \"useServerHead\",\n  \"useServerSeoMeta\",\n  \"useServerHeadSafe\"\n];\n\nfunction defineHeadPlugin(plugin) {\n  return plugin;\n}\n\nfunction hashCode(s) {\n  let h = 9;\n  for (let i = 0; i < s.length; )\n    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  return ((h ^ h >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase();\n}\nfunction hashTag(tag) {\n  return tag._h || hashCode(tag._d ? tag._d : `${tag.tag}:${tag.textContent || tag.innerHTML || \"\"}:${Object.entries(tag.props).map(([key, value]) => `${key}:${String(value)}`).join(\",\")}`);\n}\n\nfunction tagDedupeKey(tag, fn) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (fn && !fn(val))\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\n\nfunction resolveTitleTemplate(template, title) {\n  if (template == null)\n    return title || null;\n  if (typeof template === \"function\")\n    return template(title);\n  return template;\n}\n\nfunction asArray(input) {\n  return Array.isArray(input) ? input : [input];\n}\nconst InternalKeySymbol = \"_$key\";\nfunction packObject(input, options) {\n  const keys = Object.keys(input);\n  let [k, v] = keys;\n  options = options || {};\n  options.key = options.key || k;\n  options.value = options.value || v;\n  options.resolveKey = options.resolveKey || ((k2) => k2);\n  const resolveKey = (index) => {\n    const arr = asArray(options[index]);\n    return arr.find((k2) => {\n      if (typeof k2 === \"string\" && k2.includes(\".\")) {\n        return k2;\n      }\n      return k2 && keys.includes(k2);\n    });\n  };\n  const resolveValue = (k2, input2) => {\n    if (k2.includes(\".\")) {\n      const paths = k2.split(\".\");\n      let val = input2;\n      for (const path of paths)\n        val = val[path];\n      return val;\n    }\n    return input2[k2];\n  };\n  k = resolveKey(\"key\") || k;\n  v = resolveKey(\"value\") || v;\n  const dedupeKeyPrefix = input.key ? `${InternalKeySymbol}${input.key}-` : \"\";\n  let keyValue = resolveValue(k, input);\n  keyValue = options.resolveKey(keyValue);\n  return {\n    [`${dedupeKeyPrefix}${keyValue}`]: resolveValue(v, input)\n  };\n}\n\nfunction packArray(input, options) {\n  const packed = {};\n  for (const i of input) {\n    const packedObj = packObject(i, options);\n    const pKey = Object.keys(packedObj)[0];\n    const isDedupeKey = pKey.startsWith(InternalKeySymbol);\n    if (!isDedupeKey && packed[pKey]) {\n      packed[pKey] = Array.isArray(packed[pKey]) ? packed[pKey] : [packed[pKey]];\n      packed[pKey].push(Object.values(packedObj)[0]);\n    } else {\n      packed[isDedupeKey ? pKey.split(\"-\").slice(1).join(\"-\") || pKey : pKey] = packedObj[pKey];\n    }\n  }\n  return packed;\n}\n\nfunction unpackToArray(input, options) {\n  const unpacked = [];\n  const kFn = options.resolveKeyData || ((ctx) => ctx.key);\n  const vFn = options.resolveValueData || ((ctx) => ctx.value);\n  for (const [k, v] of Object.entries(input)) {\n    unpacked.push(...(Array.isArray(v) ? v : [v]).map((i) => {\n      const ctx = { key: k, value: i };\n      const val = vFn(ctx);\n      if (typeof val === \"object\")\n        return unpackToArray(val, options);\n      if (Array.isArray(val))\n        return val;\n      return {\n        [typeof options.key === \"function\" ? options.key(ctx) : options.key]: kFn(ctx),\n        [typeof options.value === \"function\" ? options.value(ctx) : options.value]: val\n      };\n    }).flat());\n  }\n  return unpacked;\n}\n\nfunction unpackToString(value, options) {\n  return Object.entries(value).map(([key, value2]) => {\n    if (typeof value2 === \"object\")\n      value2 = unpackToString(value2, options);\n    if (options.resolve) {\n      const resolved = options.resolve({ key, value: value2 });\n      if (typeof resolved !== \"undefined\")\n        return resolved;\n    }\n    if (typeof value2 === \"number\")\n      value2 = value2.toString();\n    if (typeof value2 === \"string\" && options.wrapValue) {\n      value2 = value2.replace(new RegExp(options.wrapValue, \"g\"), `\\\\${options.wrapValue}`);\n      value2 = `${options.wrapValue}${value2}${options.wrapValue}`;\n    }\n    return `${key}${options.keyValueSeparator || \"\"}${value2}`;\n  }).join(options.entrySeparator || \"\");\n}\n\nconst p = (p2) => ({ keyValue: p2, metaKey: \"property\" });\nconst k = (p2) => ({ keyValue: p2 });\nconst MetaPackingSchema = {\n  appleItunesApp: {\n    unpack: {\n      entrySeparator: \", \",\n      resolve({ key, value }) {\n        return `${fixKeyCase(key)}=${value}`;\n      }\n    }\n  },\n  articleExpirationTime: p(\"article:expiration_time\"),\n  articleModifiedTime: p(\"article:modified_time\"),\n  articlePublishedTime: p(\"article:published_time\"),\n  bookReleaseDate: p(\"book:release_date\"),\n  charset: {\n    metaKey: \"charset\"\n  },\n  contentSecurityPolicy: {\n    unpack: {\n      entrySeparator: \"; \",\n      resolve({ key, value }) {\n        return `${fixKeyCase(key)} ${value}`;\n      }\n    },\n    metaKey: \"http-equiv\"\n  },\n  contentType: {\n    metaKey: \"http-equiv\"\n  },\n  defaultStyle: {\n    metaKey: \"http-equiv\"\n  },\n  fbAppId: p(\"fb:app_id\"),\n  msapplicationConfig: k(\"msapplication-Config\"),\n  msapplicationTileColor: k(\"msapplication-TileColor\"),\n  msapplicationTileImage: k(\"msapplication-TileImage\"),\n  ogAudioSecureUrl: p(\"og:audio:secure_url\"),\n  ogAudioUrl: p(\"og:audio\"),\n  ogImageSecureUrl: p(\"og:image:secure_url\"),\n  ogImageUrl: p(\"og:image\"),\n  ogSiteName: p(\"og:site_name\"),\n  ogVideoSecureUrl: p(\"og:video:secure_url\"),\n  ogVideoUrl: p(\"og:video\"),\n  profileFirstName: p(\"profile:first_name\"),\n  profileLastName: p(\"profile:last_name\"),\n  profileUsername: p(\"profile:username\"),\n  refresh: {\n    metaKey: \"http-equiv\",\n    unpack: {\n      entrySeparator: \";\",\n      resolve({ key, value }) {\n        if (key === \"seconds\")\n          return `${value}`;\n      }\n    }\n  },\n  robots: {\n    unpack: {\n      entrySeparator: \", \",\n      resolve({ key, value }) {\n        if (typeof value === \"boolean\")\n          return `${fixKeyCase(key)}`;\n        else\n          return `${fixKeyCase(key)}:${value}`;\n      }\n    }\n  },\n  xUaCompatible: {\n    metaKey: \"http-equiv\"\n  }\n};\nconst openGraphNamespaces = [\n  \"og\",\n  \"book\",\n  \"article\",\n  \"profile\"\n];\nfunction resolveMetaKeyType(key) {\n  const fKey = fixKeyCase(key).split(\":\")[0];\n  if (openGraphNamespaces.includes(fKey))\n    return \"property\";\n  return MetaPackingSchema[key]?.metaKey || \"name\";\n}\nfunction resolveMetaKeyValue(key) {\n  return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);\n}\nfunction fixKeyCase(key) {\n  const updated = key.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  const fKey = updated.split(\"-\")[0];\n  if (openGraphNamespaces.includes(fKey) || fKey === \"twitter\")\n    return key.replace(/([A-Z])/g, \":$1\").toLowerCase();\n  return updated;\n}\nfunction changeKeyCasingDeep(input) {\n  if (Array.isArray(input)) {\n    return input.map((entry) => changeKeyCasingDeep(entry));\n  }\n  if (typeof input !== \"object\" || Array.isArray(input))\n    return input;\n  const output = {};\n  for (const [key, value] of Object.entries(input))\n    output[fixKeyCase(key)] = changeKeyCasingDeep(value);\n  return output;\n}\nfunction resolvePackedMetaObjectValue(value, key) {\n  const definition = MetaPackingSchema[key];\n  if (key === \"refresh\")\n    return `${value.seconds};url=${value.url}`;\n  return unpackToString(\n    changeKeyCasingDeep(value),\n    {\n      keyValueSeparator: \"=\",\n      entrySeparator: \", \",\n      resolve({ value: value2, key: key2 }) {\n        if (value2 === null)\n          return \"\";\n        if (typeof value2 === \"boolean\")\n          return `${key2}`;\n      },\n      ...definition?.unpack\n    }\n  );\n}\nconst ObjectArrayEntries = [\"og:image\", \"og:video\", \"og:audio\", \"twitter:image\"];\nfunction sanitize(input) {\n  const out = {};\n  Object.entries(input).forEach(([k2, v]) => {\n    if (String(v) !== \"false\" && k2)\n      out[k2] = v;\n  });\n  return out;\n}\nfunction handleObjectEntry(key, v) {\n  const value = sanitize(v);\n  const fKey = fixKeyCase(key);\n  const attr = resolveMetaKeyType(fKey);\n  if (ObjectArrayEntries.includes(fKey)) {\n    const input = {};\n    Object.entries(value).forEach(([k2, v2]) => {\n      input[`${key}${k2 === \"url\" ? \"\" : `${k2.charAt(0).toUpperCase()}${k2.slice(1)}`}`] = v2;\n    });\n    return unpackMeta(input).sort((a, b) => (a[attr]?.length || 0) - (b[attr]?.length || 0));\n  }\n  return [{ [attr]: fKey, ...value }];\n}\nfunction unpackMeta(input) {\n  const extras = [];\n  const primitives = {};\n  Object.entries(input).forEach(([key, value]) => {\n    if (!Array.isArray(value)) {\n      if (typeof value === \"object\" && value) {\n        if (ObjectArrayEntries.includes(fixKeyCase(key))) {\n          extras.push(...handleObjectEntry(key, value));\n          return;\n        }\n        primitives[key] = sanitize(value);\n      } else {\n        primitives[key] = value;\n      }\n      return;\n    }\n    value.forEach((v) => {\n      extras.push(...typeof v === \"string\" ? unpackMeta({ [key]: v }) : handleObjectEntry(key, v));\n    });\n  });\n  const meta = unpackToArray(primitives, {\n    key({ key }) {\n      return resolveMetaKeyType(key);\n    },\n    value({ key }) {\n      return key === \"charset\" ? \"charset\" : \"content\";\n    },\n    resolveKeyData({ key }) {\n      return resolveMetaKeyValue(key);\n    },\n    resolveValueData({ value, key }) {\n      if (value === null)\n        return \"_null\";\n      if (typeof value === \"object\")\n        return resolvePackedMetaObjectValue(value, key);\n      return typeof value === \"number\" ? value.toString() : value;\n    }\n  });\n  return [...extras, ...meta].map((m) => {\n    if (m.content === \"_null\")\n      m.content = null;\n    return m;\n  });\n}\nfunction packMeta(inputs) {\n  const mappedPackingSchema = Object.entries(MetaPackingSchema).map(([key, value]) => [key, value.keyValue]);\n  return packArray(inputs, {\n    key: [\"name\", \"property\", \"httpEquiv\", \"http-equiv\", \"charset\"],\n    value: [\"content\", \"charset\"],\n    resolveKey(k2) {\n      let key = mappedPackingSchema.filter((sk) => sk[1] === k2)?.[0]?.[0] || k2;\n      const replacer = (_, letter) => letter?.toUpperCase();\n      key = key.replace(/:([a-z])/g, replacer).replace(/-([a-z])/g, replacer);\n      return key;\n    }\n  });\n}\n\nconst WhitelistAttributes = {\n  htmlAttrs: [\"id\", \"class\", \"lang\", \"dir\"],\n  bodyAttrs: [\"id\", \"class\"],\n  meta: [\"id\", \"name\", \"property\", \"charset\", \"content\"],\n  noscript: [\"id\", \"textContent\"],\n  script: [\"id\", \"type\", \"textContent\"],\n  link: [\"id\", \"color\", \"crossorigin\", \"fetchpriority\", \"href\", \"hreflang\", \"imagesrcset\", \"imagesizes\", \"integrity\", \"media\", \"referrerpolicy\", \"rel\", \"sizes\", \"type\"]\n};\nfunction acceptDataAttrs(value) {\n  const filtered = {};\n  Object.keys(value || {}).filter((a) => a.startsWith(\"data-\")).forEach((a) => {\n    filtered[a] = value[a];\n  });\n  return filtered;\n}\nfunction whitelistSafeInput(input) {\n  const filtered = {};\n  Object.keys(input).forEach((key) => {\n    const tagValue = input[key];\n    if (!tagValue)\n      return;\n    switch (key) {\n      case \"title\":\n      case \"titleTemplate\":\n      case \"templateParams\":\n        filtered[key] = tagValue;\n        break;\n      case \"htmlAttrs\":\n      case \"bodyAttrs\":\n        filtered[key] = acceptDataAttrs(tagValue);\n        WhitelistAttributes[key].forEach((a) => {\n          if (tagValue[a])\n            filtered[key][a] = tagValue[a];\n        });\n        break;\n      case \"meta\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const safeMeta = acceptDataAttrs(meta);\n            WhitelistAttributes.meta.forEach((key2) => {\n              if (meta[key2])\n                safeMeta[key2] = meta[key2];\n            });\n            return safeMeta;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n      case \"link\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const link = acceptDataAttrs(meta);\n            WhitelistAttributes.link.forEach((key2) => {\n              const val = meta[key2];\n              if (key2 === \"rel\" && [\"stylesheet\", \"canonical\", \"modulepreload\", \"prerender\", \"preload\", \"prefetch\"].includes(val))\n                return;\n              if (key2 === \"href\") {\n                if (val.includes(\"javascript:\") || val.includes(\"data:\"))\n                  return;\n                link[key2] = val;\n              } else if (val) {\n                link[key2] = val;\n              }\n            });\n            return link;\n          }).filter((link) => Object.keys(link).length > 1 && !!link.rel);\n        }\n        break;\n      case \"noscript\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const noscript = acceptDataAttrs(meta);\n            WhitelistAttributes.noscript.forEach((key2) => {\n              if (meta[key2])\n                noscript[key2] = meta[key2];\n            });\n            return noscript;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n      case \"script\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((script) => {\n            const safeScript = acceptDataAttrs(script);\n            WhitelistAttributes.script.forEach((s) => {\n              if (script[s]) {\n                if (s === \"textContent\") {\n                  try {\n                    const jsonVal = typeof script[s] === \"string\" ? JSON.parse(script[s]) : script[s];\n                    safeScript[s] = JSON.stringify(jsonVal, null, 0);\n                  } catch (e) {\n                  }\n                } else {\n                  safeScript[s] = script[s];\n                }\n              }\n            });\n            return safeScript;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n    }\n  });\n  return filtered;\n}\n\nasync function normaliseTag(tagName, input, e) {\n  const tag = {\n    tag: tagName,\n    props: await normaliseProps(\n      // explicitly check for an object\n      // @ts-expect-error untyped\n      typeof input === \"object\" && typeof input !== \"function\" && !(input instanceof Promise) ? { ...input } : { [[\"script\", \"noscript\", \"style\"].includes(tagName) ? \"innerHTML\" : \"textContent\"]: input },\n      [\"templateParams\", \"titleTemplate\"].includes(tagName)\n    )\n  };\n  TagConfigKeys.forEach((k) => {\n    const val = typeof tag.props[k] !== \"undefined\" ? tag.props[k] : e[k];\n    if (typeof val !== \"undefined\") {\n      if (![\"innerHTML\", \"textContent\", \"children\"].includes(k) || TagsWithInnerContent.includes(tag.tag)) {\n        tag[k === \"children\" ? \"innerHTML\" : k] = val;\n      }\n      delete tag.props[k];\n    }\n  });\n  if (tag.props.body) {\n    tag.tagPosition = \"bodyClose\";\n    delete tag.props.body;\n  }\n  if (tag.tag === \"script\") {\n    if (typeof tag.innerHTML === \"object\") {\n      tag.innerHTML = JSON.stringify(tag.innerHTML);\n      tag.props.type = tag.props.type || \"application/json\";\n    }\n  }\n  return Array.isArray(tag.props.content) ? tag.props.content.map((v) => ({ ...tag, props: { ...tag.props, content: v } })) : tag;\n}\nfunction normaliseStyleClassProps(key, v) {\n  const sep = key === \"class\" ? \" \" : \";\";\n  if (typeof v === \"object\" && !Array.isArray(v)) {\n    v = Object.entries(v).filter(([, v2]) => v2).map(([k, v2]) => key === \"style\" ? `${k}:${v2}` : k);\n  }\n  return (Array.isArray(v) ? v.join(sep) : v).split(sep).filter((c) => c.trim()).filter(Boolean).join(sep);\n}\nasync function normaliseProps(props, virtual) {\n  for (const k of Object.keys(props)) {\n    if ([\"class\", \"style\"].includes(k)) {\n      props[k] = normaliseStyleClassProps(k, props[k]);\n      continue;\n    }\n    if (props[k] instanceof Promise)\n      props[k] = await props[k];\n    if (!virtual && !TagConfigKeys.includes(k)) {\n      const v = String(props[k]);\n      const isDataKey = k.startsWith(\"data-\");\n      if (v === \"true\" || v === \"\") {\n        props[k] = isDataKey ? \"true\" : true;\n      } else if (!props[k]) {\n        if (isDataKey && v === \"false\")\n          props[k] = \"false\";\n        else\n          delete props[k];\n      }\n    }\n  }\n  return props;\n}\nconst TagEntityBits = 10;\nasync function normaliseEntryTags(e) {\n  const tagPromises = [];\n  Object.entries(e.resolvedInput).filter(([k, v]) => typeof v !== \"undefined\" && ValidHeadTags.includes(k)).forEach(([k, value]) => {\n    const v = asArray$1(value);\n    tagPromises.push(...v.map((props) => normaliseTag(k, props, e)).flat());\n  });\n  return (await Promise.all(tagPromises)).flat().filter(Boolean).map((t, i) => {\n    t._e = e._i;\n    e.mode && (t._m = e.mode);\n    t._p = (e._i << TagEntityBits) + i;\n    return t;\n  });\n}\n\nconst TAG_WEIGHTS = {\n  // tags\n  base: -10,\n  title: 10\n};\nconst TAG_ALIASES = {\n  // relative scores to their default values\n  critical: -80,\n  high: -10,\n  low: 20\n};\nfunction tagWeight(tag) {\n  let weight = 100;\n  const priority = tag.tagPriority;\n  if (typeof priority === \"number\")\n    return priority;\n  if (tag.tag === \"meta\") {\n    if (tag.props[\"http-equiv\"] === \"content-security-policy\")\n      weight = -30;\n    if (tag.props.charset)\n      weight = -20;\n    if (tag.props.name === \"viewport\")\n      weight = -15;\n  } else if (tag.tag === \"link\" && tag.props.rel === \"preconnect\") {\n    weight = 20;\n  } else if (tag.tag in TAG_WEIGHTS) {\n    weight = TAG_WEIGHTS[tag.tag];\n  }\n  if (typeof priority === \"string\" && priority in TAG_ALIASES) {\n    return weight + TAG_ALIASES[priority];\n  }\n  return weight;\n}\nconst SortModifiers = [{ prefix: \"before:\", offset: -1 }, { prefix: \"after:\", offset: 1 }];\n\nconst NetworkEvents = [\"onload\", \"onerror\", \"onabort\", \"onprogress\", \"onloadstart\"];\nconst ScriptNetworkEvents = [\"onload\", \"onerror\"];\n\nconst sepSub = \"%separator\";\nfunction processTemplateParams(s, p, sep) {\n  if (typeof s !== \"string\" || !s.includes(\"%\"))\n    return s;\n  function sub(token) {\n    let val;\n    if ([\"s\", \"pageTitle\"].includes(token)) {\n      val = p.pageTitle;\n    } else if (token.includes(\".\")) {\n      val = token.split(\".\").reduce((acc, key) => acc ? acc[key] || void 0 : void 0, p);\n    } else {\n      val = p[token];\n    }\n    return typeof val !== \"undefined\" ? (val || \"\").replace(/\"/g, '\\\\\"') : false;\n  }\n  let decoded = s;\n  try {\n    decoded = decodeURI(s);\n  } catch {\n  }\n  const tokens = (decoded.match(/%(\\w+\\.+\\w+)|%(\\w+)/g) || []).sort().reverse();\n  tokens.forEach((token) => {\n    const re = sub(token.slice(1));\n    if (typeof re === \"string\") {\n      s = s.replace(new RegExp(`\\\\${token}(\\\\W|$)`, \"g\"), (_, args) => `${re}${args}`).trim();\n    }\n  });\n  if (s.includes(sepSub)) {\n    if (s.endsWith(sepSub))\n      s = s.slice(0, -sepSub.length).trim();\n    if (s.startsWith(sepSub))\n      s = s.slice(sepSub.length).trim();\n    s = s.replace(new RegExp(`\\\\${sepSub}\\\\s*\\\\${sepSub}`, \"g\"), sepSub);\n    s = processTemplateParams(s, { separator: sep }, sep);\n  }\n  return s;\n}\n\nexport { HasElementTags, IsBrowser, NetworkEvents, ScriptNetworkEvents, SelfClosingTags, SortModifiers, TAG_ALIASES, TAG_WEIGHTS, TagConfigKeys, TagEntityBits, TagsWithInnerContent, UniqueTags, ValidHeadTags, asArray$1 as asArray, composableNames, defineHeadPlugin, hashCode, hashTag, normaliseEntryTags, normaliseProps, normaliseStyleClassProps, normaliseTag, packMeta, processTemplateParams, resolveMetaKeyType, resolveMetaKeyValue, resolvePackedMetaObjectValue, resolveTitleTemplate, tagDedupeKey, tagWeight, unpackMeta, whitelistSafeInput };\n",
      "start": 1712518294179,
      "end": 1712518294208,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712518294209,
      "end": 1712518294209,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1712518294209,
      "end": 1712518294210,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "function asArray$1(value) {\n  return Array.isArray(value) ? value : [value];\n}\nconst SelfClosingTags = [\"meta\", \"link\", \"base\"];\nconst TagsWithInnerContent = [\"title\", \"titleTemplate\", \"script\", \"style\", \"noscript\"];\nconst HasElementTags = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst ValidHeadTags = [\n  \"title\",\n  \"titleTemplate\",\n  \"templateParams\",\n  \"base\",\n  \"htmlAttrs\",\n  \"bodyAttrs\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst UniqueTags = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\", \"templateParams\"];\nconst TagConfigKeys = [\"tagPosition\", \"tagPriority\", \"tagDuplicateStrategy\", \"children\", \"innerHTML\", \"textContent\", \"processTemplateParams\"];\nconst IsBrowser = false;\nconst composableNames = [\n  \"getActiveHead\",\n  \"useHead\",\n  \"useSeoMeta\",\n  \"useHeadSafe\",\n  \"useServerHead\",\n  \"useServerSeoMeta\",\n  \"useServerHeadSafe\"\n];\nfunction defineHeadPlugin(plugin) {\n  return plugin;\n}\nfunction hashCode(s) {\n  let h = 9;\n  for (let i = 0; i < s.length; )\n    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  return ((h ^ h >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase();\n}\nfunction hashTag(tag) {\n  return tag._h || hashCode(tag._d ? tag._d : `${tag.tag}:${tag.textContent || tag.innerHTML || \"\"}:${Object.entries(tag.props).map(([key, value]) => `${key}:${String(value)}`).join(\",\")}`);\n}\nfunction tagDedupeKey(tag, fn) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (fn && !fn(val))\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\nfunction resolveTitleTemplate(template, title) {\n  if (template == null)\n    return title || null;\n  if (typeof template === \"function\")\n    return template(title);\n  return template;\n}\nfunction asArray(input) {\n  return Array.isArray(input) ? input : [input];\n}\nconst InternalKeySymbol = \"_$key\";\nfunction packObject(input, options) {\n  const keys = Object.keys(input);\n  let [k2, v] = keys;\n  options = options || {};\n  options.key = options.key || k2;\n  options.value = options.value || v;\n  options.resolveKey = options.resolveKey || ((k22) => k22);\n  const resolveKey = (index) => {\n    const arr = asArray(options[index]);\n    return arr.find((k22) => {\n      if (typeof k22 === \"string\" && k22.includes(\".\")) {\n        return k22;\n      }\n      return k22 && keys.includes(k22);\n    });\n  };\n  const resolveValue = (k22, input2) => {\n    if (k22.includes(\".\")) {\n      const paths = k22.split(\".\");\n      let val = input2;\n      for (const path of paths)\n        val = val[path];\n      return val;\n    }\n    return input2[k22];\n  };\n  k2 = resolveKey(\"key\") || k2;\n  v = resolveKey(\"value\") || v;\n  const dedupeKeyPrefix = input.key ? `${InternalKeySymbol}${input.key}-` : \"\";\n  let keyValue = resolveValue(k2, input);\n  keyValue = options.resolveKey(keyValue);\n  return {\n    [`${dedupeKeyPrefix}${keyValue}`]: resolveValue(v, input)\n  };\n}\nfunction packArray(input, options) {\n  const packed = {};\n  for (const i of input) {\n    const packedObj = packObject(i, options);\n    const pKey = Object.keys(packedObj)[0];\n    const isDedupeKey = pKey.startsWith(InternalKeySymbol);\n    if (!isDedupeKey && packed[pKey]) {\n      packed[pKey] = Array.isArray(packed[pKey]) ? packed[pKey] : [packed[pKey]];\n      packed[pKey].push(Object.values(packedObj)[0]);\n    } else {\n      packed[isDedupeKey ? pKey.split(\"-\").slice(1).join(\"-\") || pKey : pKey] = packedObj[pKey];\n    }\n  }\n  return packed;\n}\nfunction unpackToArray(input, options) {\n  const unpacked = [];\n  const kFn = options.resolveKeyData || ((ctx) => ctx.key);\n  const vFn = options.resolveValueData || ((ctx) => ctx.value);\n  for (const [k2, v] of Object.entries(input)) {\n    unpacked.push(...(Array.isArray(v) ? v : [v]).map((i) => {\n      const ctx = { key: k2, value: i };\n      const val = vFn(ctx);\n      if (typeof val === \"object\")\n        return unpackToArray(val, options);\n      if (Array.isArray(val))\n        return val;\n      return {\n        [typeof options.key === \"function\" ? options.key(ctx) : options.key]: kFn(ctx),\n        [typeof options.value === \"function\" ? options.value(ctx) : options.value]: val\n      };\n    }).flat());\n  }\n  return unpacked;\n}\nfunction unpackToString(value, options) {\n  return Object.entries(value).map(([key, value2]) => {\n    if (typeof value2 === \"object\")\n      value2 = unpackToString(value2, options);\n    if (options.resolve) {\n      const resolved = options.resolve({ key, value: value2 });\n      if (typeof resolved !== \"undefined\")\n        return resolved;\n    }\n    if (typeof value2 === \"number\")\n      value2 = value2.toString();\n    if (typeof value2 === \"string\" && options.wrapValue) {\n      value2 = value2.replace(new RegExp(options.wrapValue, \"g\"), `\\\\${options.wrapValue}`);\n      value2 = `${options.wrapValue}${value2}${options.wrapValue}`;\n    }\n    return `${key}${options.keyValueSeparator || \"\"}${value2}`;\n  }).join(options.entrySeparator || \"\");\n}\nconst p = (p2) => ({ keyValue: p2, metaKey: \"property\" });\nconst k = (p2) => ({ keyValue: p2 });\nconst MetaPackingSchema = {\n  appleItunesApp: {\n    unpack: {\n      entrySeparator: \", \",\n      resolve({ key, value }) {\n        return `${fixKeyCase(key)}=${value}`;\n      }\n    }\n  },\n  articleExpirationTime: p(\"article:expiration_time\"),\n  articleModifiedTime: p(\"article:modified_time\"),\n  articlePublishedTime: p(\"article:published_time\"),\n  bookReleaseDate: p(\"book:release_date\"),\n  charset: {\n    metaKey: \"charset\"\n  },\n  contentSecurityPolicy: {\n    unpack: {\n      entrySeparator: \"; \",\n      resolve({ key, value }) {\n        return `${fixKeyCase(key)} ${value}`;\n      }\n    },\n    metaKey: \"http-equiv\"\n  },\n  contentType: {\n    metaKey: \"http-equiv\"\n  },\n  defaultStyle: {\n    metaKey: \"http-equiv\"\n  },\n  fbAppId: p(\"fb:app_id\"),\n  msapplicationConfig: k(\"msapplication-Config\"),\n  msapplicationTileColor: k(\"msapplication-TileColor\"),\n  msapplicationTileImage: k(\"msapplication-TileImage\"),\n  ogAudioSecureUrl: p(\"og:audio:secure_url\"),\n  ogAudioUrl: p(\"og:audio\"),\n  ogImageSecureUrl: p(\"og:image:secure_url\"),\n  ogImageUrl: p(\"og:image\"),\n  ogSiteName: p(\"og:site_name\"),\n  ogVideoSecureUrl: p(\"og:video:secure_url\"),\n  ogVideoUrl: p(\"og:video\"),\n  profileFirstName: p(\"profile:first_name\"),\n  profileLastName: p(\"profile:last_name\"),\n  profileUsername: p(\"profile:username\"),\n  refresh: {\n    metaKey: \"http-equiv\",\n    unpack: {\n      entrySeparator: \";\",\n      resolve({ key, value }) {\n        if (key === \"seconds\")\n          return `${value}`;\n      }\n    }\n  },\n  robots: {\n    unpack: {\n      entrySeparator: \", \",\n      resolve({ key, value }) {\n        if (typeof value === \"boolean\")\n          return `${fixKeyCase(key)}`;\n        else\n          return `${fixKeyCase(key)}:${value}`;\n      }\n    }\n  },\n  xUaCompatible: {\n    metaKey: \"http-equiv\"\n  }\n};\nconst openGraphNamespaces = [\n  \"og\",\n  \"book\",\n  \"article\",\n  \"profile\"\n];\nfunction resolveMetaKeyType(key) {\n  const fKey = fixKeyCase(key).split(\":\")[0];\n  if (openGraphNamespaces.includes(fKey))\n    return \"property\";\n  return MetaPackingSchema[key]?.metaKey || \"name\";\n}\nfunction resolveMetaKeyValue(key) {\n  return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);\n}\nfunction fixKeyCase(key) {\n  const updated = key.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  const fKey = updated.split(\"-\")[0];\n  if (openGraphNamespaces.includes(fKey) || fKey === \"twitter\")\n    return key.replace(/([A-Z])/g, \":$1\").toLowerCase();\n  return updated;\n}\nfunction changeKeyCasingDeep(input) {\n  if (Array.isArray(input)) {\n    return input.map((entry) => changeKeyCasingDeep(entry));\n  }\n  if (typeof input !== \"object\" || Array.isArray(input))\n    return input;\n  const output = {};\n  for (const [key, value] of Object.entries(input))\n    output[fixKeyCase(key)] = changeKeyCasingDeep(value);\n  return output;\n}\nfunction resolvePackedMetaObjectValue(value, key) {\n  const definition = MetaPackingSchema[key];\n  if (key === \"refresh\")\n    return `${value.seconds};url=${value.url}`;\n  return unpackToString(\n    changeKeyCasingDeep(value),\n    {\n      keyValueSeparator: \"=\",\n      entrySeparator: \", \",\n      resolve({ value: value2, key: key2 }) {\n        if (value2 === null)\n          return \"\";\n        if (typeof value2 === \"boolean\")\n          return `${key2}`;\n      },\n      ...definition?.unpack\n    }\n  );\n}\nconst ObjectArrayEntries = [\"og:image\", \"og:video\", \"og:audio\", \"twitter:image\"];\nfunction sanitize(input) {\n  const out = {};\n  Object.entries(input).forEach(([k2, v]) => {\n    if (String(v) !== \"false\" && k2)\n      out[k2] = v;\n  });\n  return out;\n}\nfunction handleObjectEntry(key, v) {\n  const value = sanitize(v);\n  const fKey = fixKeyCase(key);\n  const attr = resolveMetaKeyType(fKey);\n  if (ObjectArrayEntries.includes(fKey)) {\n    const input = {};\n    Object.entries(value).forEach(([k2, v2]) => {\n      input[`${key}${k2 === \"url\" ? \"\" : `${k2.charAt(0).toUpperCase()}${k2.slice(1)}`}`] = v2;\n    });\n    return unpackMeta(input).sort((a, b) => (a[attr]?.length || 0) - (b[attr]?.length || 0));\n  }\n  return [{ [attr]: fKey, ...value }];\n}\nfunction unpackMeta(input) {\n  const extras = [];\n  const primitives = {};\n  Object.entries(input).forEach(([key, value]) => {\n    if (!Array.isArray(value)) {\n      if (typeof value === \"object\" && value) {\n        if (ObjectArrayEntries.includes(fixKeyCase(key))) {\n          extras.push(...handleObjectEntry(key, value));\n          return;\n        }\n        primitives[key] = sanitize(value);\n      } else {\n        primitives[key] = value;\n      }\n      return;\n    }\n    value.forEach((v) => {\n      extras.push(...typeof v === \"string\" ? unpackMeta({ [key]: v }) : handleObjectEntry(key, v));\n    });\n  });\n  const meta = unpackToArray(primitives, {\n    key({ key }) {\n      return resolveMetaKeyType(key);\n    },\n    value({ key }) {\n      return key === \"charset\" ? \"charset\" : \"content\";\n    },\n    resolveKeyData({ key }) {\n      return resolveMetaKeyValue(key);\n    },\n    resolveValueData({ value, key }) {\n      if (value === null)\n        return \"_null\";\n      if (typeof value === \"object\")\n        return resolvePackedMetaObjectValue(value, key);\n      return typeof value === \"number\" ? value.toString() : value;\n    }\n  });\n  return [...extras, ...meta].map((m) => {\n    if (m.content === \"_null\")\n      m.content = null;\n    return m;\n  });\n}\nfunction packMeta(inputs) {\n  const mappedPackingSchema = Object.entries(MetaPackingSchema).map(([key, value]) => [key, value.keyValue]);\n  return packArray(inputs, {\n    key: [\"name\", \"property\", \"httpEquiv\", \"http-equiv\", \"charset\"],\n    value: [\"content\", \"charset\"],\n    resolveKey(k2) {\n      let key = mappedPackingSchema.filter((sk) => sk[1] === k2)?.[0]?.[0] || k2;\n      const replacer = (_, letter) => letter?.toUpperCase();\n      key = key.replace(/:([a-z])/g, replacer).replace(/-([a-z])/g, replacer);\n      return key;\n    }\n  });\n}\nconst WhitelistAttributes = {\n  htmlAttrs: [\"id\", \"class\", \"lang\", \"dir\"],\n  bodyAttrs: [\"id\", \"class\"],\n  meta: [\"id\", \"name\", \"property\", \"charset\", \"content\"],\n  noscript: [\"id\", \"textContent\"],\n  script: [\"id\", \"type\", \"textContent\"],\n  link: [\"id\", \"color\", \"crossorigin\", \"fetchpriority\", \"href\", \"hreflang\", \"imagesrcset\", \"imagesizes\", \"integrity\", \"media\", \"referrerpolicy\", \"rel\", \"sizes\", \"type\"]\n};\nfunction acceptDataAttrs(value) {\n  const filtered = {};\n  Object.keys(value || {}).filter((a) => a.startsWith(\"data-\")).forEach((a) => {\n    filtered[a] = value[a];\n  });\n  return filtered;\n}\nfunction whitelistSafeInput(input) {\n  const filtered = {};\n  Object.keys(input).forEach((key) => {\n    const tagValue = input[key];\n    if (!tagValue)\n      return;\n    switch (key) {\n      case \"title\":\n      case \"titleTemplate\":\n      case \"templateParams\":\n        filtered[key] = tagValue;\n        break;\n      case \"htmlAttrs\":\n      case \"bodyAttrs\":\n        filtered[key] = acceptDataAttrs(tagValue);\n        WhitelistAttributes[key].forEach((a) => {\n          if (tagValue[a])\n            filtered[key][a] = tagValue[a];\n        });\n        break;\n      case \"meta\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const safeMeta = acceptDataAttrs(meta);\n            WhitelistAttributes.meta.forEach((key2) => {\n              if (meta[key2])\n                safeMeta[key2] = meta[key2];\n            });\n            return safeMeta;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n      case \"link\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const link = acceptDataAttrs(meta);\n            WhitelistAttributes.link.forEach((key2) => {\n              const val = meta[key2];\n              if (key2 === \"rel\" && [\"stylesheet\", \"canonical\", \"modulepreload\", \"prerender\", \"preload\", \"prefetch\"].includes(val))\n                return;\n              if (key2 === \"href\") {\n                if (val.includes(\"javascript:\") || val.includes(\"data:\"))\n                  return;\n                link[key2] = val;\n              } else if (val) {\n                link[key2] = val;\n              }\n            });\n            return link;\n          }).filter((link) => Object.keys(link).length > 1 && !!link.rel);\n        }\n        break;\n      case \"noscript\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const noscript = acceptDataAttrs(meta);\n            WhitelistAttributes.noscript.forEach((key2) => {\n              if (meta[key2])\n                noscript[key2] = meta[key2];\n            });\n            return noscript;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n      case \"script\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((script) => {\n            const safeScript = acceptDataAttrs(script);\n            WhitelistAttributes.script.forEach((s) => {\n              if (script[s]) {\n                if (s === \"textContent\") {\n                  try {\n                    const jsonVal = typeof script[s] === \"string\" ? JSON.parse(script[s]) : script[s];\n                    safeScript[s] = JSON.stringify(jsonVal, null, 0);\n                  } catch (e) {\n                  }\n                } else {\n                  safeScript[s] = script[s];\n                }\n              }\n            });\n            return safeScript;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n    }\n  });\n  return filtered;\n}\nasync function normaliseTag(tagName, input, e) {\n  const tag = {\n    tag: tagName,\n    props: await normaliseProps(\n      // explicitly check for an object\n      // @ts-expect-error untyped\n      typeof input === \"object\" && typeof input !== \"function\" && !(input instanceof Promise) ? { ...input } : { [[\"script\", \"noscript\", \"style\"].includes(tagName) ? \"innerHTML\" : \"textContent\"]: input },\n      [\"templateParams\", \"titleTemplate\"].includes(tagName)\n    )\n  };\n  TagConfigKeys.forEach((k2) => {\n    const val = typeof tag.props[k2] !== \"undefined\" ? tag.props[k2] : e[k2];\n    if (typeof val !== \"undefined\") {\n      if (![\"innerHTML\", \"textContent\", \"children\"].includes(k2) || TagsWithInnerContent.includes(tag.tag)) {\n        tag[k2 === \"children\" ? \"innerHTML\" : k2] = val;\n      }\n      delete tag.props[k2];\n    }\n  });\n  if (tag.props.body) {\n    tag.tagPosition = \"bodyClose\";\n    delete tag.props.body;\n  }\n  if (tag.tag === \"script\") {\n    if (typeof tag.innerHTML === \"object\") {\n      tag.innerHTML = JSON.stringify(tag.innerHTML);\n      tag.props.type = tag.props.type || \"application/json\";\n    }\n  }\n  return Array.isArray(tag.props.content) ? tag.props.content.map((v) => ({ ...tag, props: { ...tag.props, content: v } })) : tag;\n}\nfunction normaliseStyleClassProps(key, v) {\n  const sep = key === \"class\" ? \" \" : \";\";\n  if (typeof v === \"object\" && !Array.isArray(v)) {\n    v = Object.entries(v).filter(([, v2]) => v2).map(([k2, v2]) => key === \"style\" ? `${k2}:${v2}` : k2);\n  }\n  return (Array.isArray(v) ? v.join(sep) : v).split(sep).filter((c) => c.trim()).filter(Boolean).join(sep);\n}\nasync function normaliseProps(props, virtual) {\n  for (const k2 of Object.keys(props)) {\n    if ([\"class\", \"style\"].includes(k2)) {\n      props[k2] = normaliseStyleClassProps(k2, props[k2]);\n      continue;\n    }\n    if (props[k2] instanceof Promise)\n      props[k2] = await props[k2];\n    if (!virtual && !TagConfigKeys.includes(k2)) {\n      const v = String(props[k2]);\n      const isDataKey = k2.startsWith(\"data-\");\n      if (v === \"true\" || v === \"\") {\n        props[k2] = isDataKey ? \"true\" : true;\n      } else if (!props[k2]) {\n        if (isDataKey && v === \"false\")\n          props[k2] = \"false\";\n        else\n          delete props[k2];\n      }\n    }\n  }\n  return props;\n}\nconst TagEntityBits = 10;\nasync function normaliseEntryTags(e) {\n  const tagPromises = [];\n  Object.entries(e.resolvedInput).filter(([k2, v]) => typeof v !== \"undefined\" && ValidHeadTags.includes(k2)).forEach(([k2, value]) => {\n    const v = asArray$1(value);\n    tagPromises.push(...v.map((props) => normaliseTag(k2, props, e)).flat());\n  });\n  return (await Promise.all(tagPromises)).flat().filter(Boolean).map((t, i) => {\n    t._e = e._i;\n    e.mode && (t._m = e.mode);\n    t._p = (e._i << TagEntityBits) + i;\n    return t;\n  });\n}\nconst TAG_WEIGHTS = {\n  // tags\n  base: -10,\n  title: 10\n};\nconst TAG_ALIASES = {\n  // relative scores to their default values\n  critical: -80,\n  high: -10,\n  low: 20\n};\nfunction tagWeight(tag) {\n  let weight = 100;\n  const priority = tag.tagPriority;\n  if (typeof priority === \"number\")\n    return priority;\n  if (tag.tag === \"meta\") {\n    if (tag.props[\"http-equiv\"] === \"content-security-policy\")\n      weight = -30;\n    if (tag.props.charset)\n      weight = -20;\n    if (tag.props.name === \"viewport\")\n      weight = -15;\n  } else if (tag.tag === \"link\" && tag.props.rel === \"preconnect\") {\n    weight = 20;\n  } else if (tag.tag in TAG_WEIGHTS) {\n    weight = TAG_WEIGHTS[tag.tag];\n  }\n  if (typeof priority === \"string\" && priority in TAG_ALIASES) {\n    return weight + TAG_ALIASES[priority];\n  }\n  return weight;\n}\nconst SortModifiers = [{ prefix: \"before:\", offset: -1 }, { prefix: \"after:\", offset: 1 }];\nconst NetworkEvents = [\"onload\", \"onerror\", \"onabort\", \"onprogress\", \"onloadstart\"];\nconst ScriptNetworkEvents = [\"onload\", \"onerror\"];\nconst sepSub = \"%separator\";\nfunction processTemplateParams(s, p2, sep) {\n  if (typeof s !== \"string\" || !s.includes(\"%\"))\n    return s;\n  function sub(token) {\n    let val;\n    if ([\"s\", \"pageTitle\"].includes(token)) {\n      val = p2.pageTitle;\n    } else if (token.includes(\".\")) {\n      val = token.split(\".\").reduce((acc, key) => acc ? acc[key] || void 0 : void 0, p2);\n    } else {\n      val = p2[token];\n    }\n    return typeof val !== \"undefined\" ? (val || \"\").replace(/\"/g, '\\\\\"') : false;\n  }\n  let decoded = s;\n  try {\n    decoded = decodeURI(s);\n  } catch {\n  }\n  const tokens = (decoded.match(/%(\\w+\\.+\\w+)|%(\\w+)/g) || []).sort().reverse();\n  tokens.forEach((token) => {\n    const re = sub(token.slice(1));\n    if (typeof re === \"string\") {\n      s = s.replace(new RegExp(`\\\\${token}(\\\\W|$)`, \"g\"), (_, args) => `${re}${args}`).trim();\n    }\n  });\n  if (s.includes(sepSub)) {\n    if (s.endsWith(sepSub))\n      s = s.slice(0, -sepSub.length).trim();\n    if (s.startsWith(sepSub))\n      s = s.slice(sepSub.length).trim();\n    s = s.replace(new RegExp(`\\\\${sepSub}\\\\s*\\\\${sepSub}`, \"g\"), sepSub);\n    s = processTemplateParams(s, { separator: sep }, sep);\n  }\n  return s;\n}\nexport { HasElementTags, IsBrowser, NetworkEvents, ScriptNetworkEvents, SelfClosingTags, SortModifiers, TAG_ALIASES, TAG_WEIGHTS, TagConfigKeys, TagEntityBits, TagsWithInnerContent, UniqueTags, ValidHeadTags, asArray$1 as asArray, composableNames, defineHeadPlugin, hashCode, hashTag, normaliseEntryTags, normaliseProps, normaliseStyleClassProps, normaliseTag, packMeta, processTemplateParams, resolveMetaKeyType, resolveMetaKeyValue, resolvePackedMetaObjectValue, resolveTitleTemplate, tagDedupeKey, tagWeight, unpackMeta, whitelistSafeInput };\n",
      "start": 1712518294210,
      "end": 1712518294223,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/home/bear/.app/purrtun-frontend/node_modules/.pnpm/@unhead+shared@1.9.4/node_modules/@unhead/shared/dist/index.mjs\"],\n  \"sourcesContent\": [\"function asArray$1(value) {\\n  return Array.isArray(value) ? value : [value];\\n}\\n\\nconst SelfClosingTags = [\\\"meta\\\", \\\"link\\\", \\\"base\\\"];\\nconst TagsWithInnerContent = [\\\"title\\\", \\\"titleTemplate\\\", \\\"script\\\", \\\"style\\\", \\\"noscript\\\"];\\nconst HasElementTags = [\\n  \\\"base\\\",\\n  \\\"meta\\\",\\n  \\\"link\\\",\\n  \\\"style\\\",\\n  \\\"script\\\",\\n  \\\"noscript\\\"\\n];\\nconst ValidHeadTags = [\\n  \\\"title\\\",\\n  \\\"titleTemplate\\\",\\n  \\\"templateParams\\\",\\n  \\\"base\\\",\\n  \\\"htmlAttrs\\\",\\n  \\\"bodyAttrs\\\",\\n  \\\"meta\\\",\\n  \\\"link\\\",\\n  \\\"style\\\",\\n  \\\"script\\\",\\n  \\\"noscript\\\"\\n];\\nconst UniqueTags = [\\\"base\\\", \\\"title\\\", \\\"titleTemplate\\\", \\\"bodyAttrs\\\", \\\"htmlAttrs\\\", \\\"templateParams\\\"];\\nconst TagConfigKeys = [\\\"tagPosition\\\", \\\"tagPriority\\\", \\\"tagDuplicateStrategy\\\", \\\"children\\\", \\\"innerHTML\\\", \\\"textContent\\\", \\\"processTemplateParams\\\"];\\nconst IsBrowser = typeof window !== \\\"undefined\\\";\\nconst composableNames = [\\n  \\\"getActiveHead\\\",\\n  \\\"useHead\\\",\\n  \\\"useSeoMeta\\\",\\n  \\\"useHeadSafe\\\",\\n  \\\"useServerHead\\\",\\n  \\\"useServerSeoMeta\\\",\\n  \\\"useServerHeadSafe\\\"\\n];\\n\\nfunction defineHeadPlugin(plugin) {\\n  return plugin;\\n}\\n\\nfunction hashCode(s) {\\n  let h = 9;\\n  for (let i = 0; i < s.length; )\\n    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\\n  return ((h ^ h >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase();\\n}\\nfunction hashTag(tag) {\\n  return tag._h || hashCode(tag._d ? tag._d : `${tag.tag}:${tag.textContent || tag.innerHTML || \\\"\\\"}:${Object.entries(tag.props).map(([key, value]) => `${key}:${String(value)}`).join(\\\",\\\")}`);\\n}\\n\\nfunction tagDedupeKey(tag, fn) {\\n  const { props, tag: tagName } = tag;\\n  if (UniqueTags.includes(tagName))\\n    return tagName;\\n  if (tagName === \\\"link\\\" && props.rel === \\\"canonical\\\")\\n    return \\\"canonical\\\";\\n  if (props.charset)\\n    return \\\"charset\\\";\\n  const name = [\\\"id\\\"];\\n  if (tagName === \\\"meta\\\")\\n    name.push(...[\\\"name\\\", \\\"property\\\", \\\"http-equiv\\\"]);\\n  for (const n of name) {\\n    if (typeof props[n] !== \\\"undefined\\\") {\\n      const val = String(props[n]);\\n      if (fn && !fn(val))\\n        return false;\\n      return `${tagName}:${n}:${val}`;\\n    }\\n  }\\n  return false;\\n}\\n\\nfunction resolveTitleTemplate(template, title) {\\n  if (template == null)\\n    return title || null;\\n  if (typeof template === \\\"function\\\")\\n    return template(title);\\n  return template;\\n}\\n\\nfunction asArray(input) {\\n  return Array.isArray(input) ? input : [input];\\n}\\nconst InternalKeySymbol = \\\"_$key\\\";\\nfunction packObject(input, options) {\\n  const keys = Object.keys(input);\\n  let [k, v] = keys;\\n  options = options || {};\\n  options.key = options.key || k;\\n  options.value = options.value || v;\\n  options.resolveKey = options.resolveKey || ((k2) => k2);\\n  const resolveKey = (index) => {\\n    const arr = asArray(options[index]);\\n    return arr.find((k2) => {\\n      if (typeof k2 === \\\"string\\\" && k2.includes(\\\".\\\")) {\\n        return k2;\\n      }\\n      return k2 && keys.includes(k2);\\n    });\\n  };\\n  const resolveValue = (k2, input2) => {\\n    if (k2.includes(\\\".\\\")) {\\n      const paths = k2.split(\\\".\\\");\\n      let val = input2;\\n      for (const path of paths)\\n        val = val[path];\\n      return val;\\n    }\\n    return input2[k2];\\n  };\\n  k = resolveKey(\\\"key\\\") || k;\\n  v = resolveKey(\\\"value\\\") || v;\\n  const dedupeKeyPrefix = input.key ? `${InternalKeySymbol}${input.key}-` : \\\"\\\";\\n  let keyValue = resolveValue(k, input);\\n  keyValue = options.resolveKey(keyValue);\\n  return {\\n    [`${dedupeKeyPrefix}${keyValue}`]: resolveValue(v, input)\\n  };\\n}\\n\\nfunction packArray(input, options) {\\n  const packed = {};\\n  for (const i of input) {\\n    const packedObj = packObject(i, options);\\n    const pKey = Object.keys(packedObj)[0];\\n    const isDedupeKey = pKey.startsWith(InternalKeySymbol);\\n    if (!isDedupeKey && packed[pKey]) {\\n      packed[pKey] = Array.isArray(packed[pKey]) ? packed[pKey] : [packed[pKey]];\\n      packed[pKey].push(Object.values(packedObj)[0]);\\n    } else {\\n      packed[isDedupeKey ? pKey.split(\\\"-\\\").slice(1).join(\\\"-\\\") || pKey : pKey] = packedObj[pKey];\\n    }\\n  }\\n  return packed;\\n}\\n\\nfunction unpackToArray(input, options) {\\n  const unpacked = [];\\n  const kFn = options.resolveKeyData || ((ctx) => ctx.key);\\n  const vFn = options.resolveValueData || ((ctx) => ctx.value);\\n  for (const [k, v] of Object.entries(input)) {\\n    unpacked.push(...(Array.isArray(v) ? v : [v]).map((i) => {\\n      const ctx = { key: k, value: i };\\n      const val = vFn(ctx);\\n      if (typeof val === \\\"object\\\")\\n        return unpackToArray(val, options);\\n      if (Array.isArray(val))\\n        return val;\\n      return {\\n        [typeof options.key === \\\"function\\\" ? options.key(ctx) : options.key]: kFn(ctx),\\n        [typeof options.value === \\\"function\\\" ? options.value(ctx) : options.value]: val\\n      };\\n    }).flat());\\n  }\\n  return unpacked;\\n}\\n\\nfunction unpackToString(value, options) {\\n  return Object.entries(value).map(([key, value2]) => {\\n    if (typeof value2 === \\\"object\\\")\\n      value2 = unpackToString(value2, options);\\n    if (options.resolve) {\\n      const resolved = options.resolve({ key, value: value2 });\\n      if (typeof resolved !== \\\"undefined\\\")\\n        return resolved;\\n    }\\n    if (typeof value2 === \\\"number\\\")\\n      value2 = value2.toString();\\n    if (typeof value2 === \\\"string\\\" && options.wrapValue) {\\n      value2 = value2.replace(new RegExp(options.wrapValue, \\\"g\\\"), `\\\\\\\\${options.wrapValue}`);\\n      value2 = `${options.wrapValue}${value2}${options.wrapValue}`;\\n    }\\n    return `${key}${options.keyValueSeparator || \\\"\\\"}${value2}`;\\n  }).join(options.entrySeparator || \\\"\\\");\\n}\\n\\nconst p = (p2) => ({ keyValue: p2, metaKey: \\\"property\\\" });\\nconst k = (p2) => ({ keyValue: p2 });\\nconst MetaPackingSchema = {\\n  appleItunesApp: {\\n    unpack: {\\n      entrySeparator: \\\", \\\",\\n      resolve({ key, value }) {\\n        return `${fixKeyCase(key)}=${value}`;\\n      }\\n    }\\n  },\\n  articleExpirationTime: p(\\\"article:expiration_time\\\"),\\n  articleModifiedTime: p(\\\"article:modified_time\\\"),\\n  articlePublishedTime: p(\\\"article:published_time\\\"),\\n  bookReleaseDate: p(\\\"book:release_date\\\"),\\n  charset: {\\n    metaKey: \\\"charset\\\"\\n  },\\n  contentSecurityPolicy: {\\n    unpack: {\\n      entrySeparator: \\\"; \\\",\\n      resolve({ key, value }) {\\n        return `${fixKeyCase(key)} ${value}`;\\n      }\\n    },\\n    metaKey: \\\"http-equiv\\\"\\n  },\\n  contentType: {\\n    metaKey: \\\"http-equiv\\\"\\n  },\\n  defaultStyle: {\\n    metaKey: \\\"http-equiv\\\"\\n  },\\n  fbAppId: p(\\\"fb:app_id\\\"),\\n  msapplicationConfig: k(\\\"msapplication-Config\\\"),\\n  msapplicationTileColor: k(\\\"msapplication-TileColor\\\"),\\n  msapplicationTileImage: k(\\\"msapplication-TileImage\\\"),\\n  ogAudioSecureUrl: p(\\\"og:audio:secure_url\\\"),\\n  ogAudioUrl: p(\\\"og:audio\\\"),\\n  ogImageSecureUrl: p(\\\"og:image:secure_url\\\"),\\n  ogImageUrl: p(\\\"og:image\\\"),\\n  ogSiteName: p(\\\"og:site_name\\\"),\\n  ogVideoSecureUrl: p(\\\"og:video:secure_url\\\"),\\n  ogVideoUrl: p(\\\"og:video\\\"),\\n  profileFirstName: p(\\\"profile:first_name\\\"),\\n  profileLastName: p(\\\"profile:last_name\\\"),\\n  profileUsername: p(\\\"profile:username\\\"),\\n  refresh: {\\n    metaKey: \\\"http-equiv\\\",\\n    unpack: {\\n      entrySeparator: \\\";\\\",\\n      resolve({ key, value }) {\\n        if (key === \\\"seconds\\\")\\n          return `${value}`;\\n      }\\n    }\\n  },\\n  robots: {\\n    unpack: {\\n      entrySeparator: \\\", \\\",\\n      resolve({ key, value }) {\\n        if (typeof value === \\\"boolean\\\")\\n          return `${fixKeyCase(key)}`;\\n        else\\n          return `${fixKeyCase(key)}:${value}`;\\n      }\\n    }\\n  },\\n  xUaCompatible: {\\n    metaKey: \\\"http-equiv\\\"\\n  }\\n};\\nconst openGraphNamespaces = [\\n  \\\"og\\\",\\n  \\\"book\\\",\\n  \\\"article\\\",\\n  \\\"profile\\\"\\n];\\nfunction resolveMetaKeyType(key) {\\n  const fKey = fixKeyCase(key).split(\\\":\\\")[0];\\n  if (openGraphNamespaces.includes(fKey))\\n    return \\\"property\\\";\\n  return MetaPackingSchema[key]?.metaKey || \\\"name\\\";\\n}\\nfunction resolveMetaKeyValue(key) {\\n  return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);\\n}\\nfunction fixKeyCase(key) {\\n  const updated = key.replace(/([A-Z])/g, \\\"-$1\\\").toLowerCase();\\n  const fKey = updated.split(\\\"-\\\")[0];\\n  if (openGraphNamespaces.includes(fKey) || fKey === \\\"twitter\\\")\\n    return key.replace(/([A-Z])/g, \\\":$1\\\").toLowerCase();\\n  return updated;\\n}\\nfunction changeKeyCasingDeep(input) {\\n  if (Array.isArray(input)) {\\n    return input.map((entry) => changeKeyCasingDeep(entry));\\n  }\\n  if (typeof input !== \\\"object\\\" || Array.isArray(input))\\n    return input;\\n  const output = {};\\n  for (const [key, value] of Object.entries(input))\\n    output[fixKeyCase(key)] = changeKeyCasingDeep(value);\\n  return output;\\n}\\nfunction resolvePackedMetaObjectValue(value, key) {\\n  const definition = MetaPackingSchema[key];\\n  if (key === \\\"refresh\\\")\\n    return `${value.seconds};url=${value.url}`;\\n  return unpackToString(\\n    changeKeyCasingDeep(value),\\n    {\\n      keyValueSeparator: \\\"=\\\",\\n      entrySeparator: \\\", \\\",\\n      resolve({ value: value2, key: key2 }) {\\n        if (value2 === null)\\n          return \\\"\\\";\\n        if (typeof value2 === \\\"boolean\\\")\\n          return `${key2}`;\\n      },\\n      ...definition?.unpack\\n    }\\n  );\\n}\\nconst ObjectArrayEntries = [\\\"og:image\\\", \\\"og:video\\\", \\\"og:audio\\\", \\\"twitter:image\\\"];\\nfunction sanitize(input) {\\n  const out = {};\\n  Object.entries(input).forEach(([k2, v]) => {\\n    if (String(v) !== \\\"false\\\" && k2)\\n      out[k2] = v;\\n  });\\n  return out;\\n}\\nfunction handleObjectEntry(key, v) {\\n  const value = sanitize(v);\\n  const fKey = fixKeyCase(key);\\n  const attr = resolveMetaKeyType(fKey);\\n  if (ObjectArrayEntries.includes(fKey)) {\\n    const input = {};\\n    Object.entries(value).forEach(([k2, v2]) => {\\n      input[`${key}${k2 === \\\"url\\\" ? \\\"\\\" : `${k2.charAt(0).toUpperCase()}${k2.slice(1)}`}`] = v2;\\n    });\\n    return unpackMeta(input).sort((a, b) => (a[attr]?.length || 0) - (b[attr]?.length || 0));\\n  }\\n  return [{ [attr]: fKey, ...value }];\\n}\\nfunction unpackMeta(input) {\\n  const extras = [];\\n  const primitives = {};\\n  Object.entries(input).forEach(([key, value]) => {\\n    if (!Array.isArray(value)) {\\n      if (typeof value === \\\"object\\\" && value) {\\n        if (ObjectArrayEntries.includes(fixKeyCase(key))) {\\n          extras.push(...handleObjectEntry(key, value));\\n          return;\\n        }\\n        primitives[key] = sanitize(value);\\n      } else {\\n        primitives[key] = value;\\n      }\\n      return;\\n    }\\n    value.forEach((v) => {\\n      extras.push(...typeof v === \\\"string\\\" ? unpackMeta({ [key]: v }) : handleObjectEntry(key, v));\\n    });\\n  });\\n  const meta = unpackToArray(primitives, {\\n    key({ key }) {\\n      return resolveMetaKeyType(key);\\n    },\\n    value({ key }) {\\n      return key === \\\"charset\\\" ? \\\"charset\\\" : \\\"content\\\";\\n    },\\n    resolveKeyData({ key }) {\\n      return resolveMetaKeyValue(key);\\n    },\\n    resolveValueData({ value, key }) {\\n      if (value === null)\\n        return \\\"_null\\\";\\n      if (typeof value === \\\"object\\\")\\n        return resolvePackedMetaObjectValue(value, key);\\n      return typeof value === \\\"number\\\" ? value.toString() : value;\\n    }\\n  });\\n  return [...extras, ...meta].map((m) => {\\n    if (m.content === \\\"_null\\\")\\n      m.content = null;\\n    return m;\\n  });\\n}\\nfunction packMeta(inputs) {\\n  const mappedPackingSchema = Object.entries(MetaPackingSchema).map(([key, value]) => [key, value.keyValue]);\\n  return packArray(inputs, {\\n    key: [\\\"name\\\", \\\"property\\\", \\\"httpEquiv\\\", \\\"http-equiv\\\", \\\"charset\\\"],\\n    value: [\\\"content\\\", \\\"charset\\\"],\\n    resolveKey(k2) {\\n      let key = mappedPackingSchema.filter((sk) => sk[1] === k2)?.[0]?.[0] || k2;\\n      const replacer = (_, letter) => letter?.toUpperCase();\\n      key = key.replace(/:([a-z])/g, replacer).replace(/-([a-z])/g, replacer);\\n      return key;\\n    }\\n  });\\n}\\n\\nconst WhitelistAttributes = {\\n  htmlAttrs: [\\\"id\\\", \\\"class\\\", \\\"lang\\\", \\\"dir\\\"],\\n  bodyAttrs: [\\\"id\\\", \\\"class\\\"],\\n  meta: [\\\"id\\\", \\\"name\\\", \\\"property\\\", \\\"charset\\\", \\\"content\\\"],\\n  noscript: [\\\"id\\\", \\\"textContent\\\"],\\n  script: [\\\"id\\\", \\\"type\\\", \\\"textContent\\\"],\\n  link: [\\\"id\\\", \\\"color\\\", \\\"crossorigin\\\", \\\"fetchpriority\\\", \\\"href\\\", \\\"hreflang\\\", \\\"imagesrcset\\\", \\\"imagesizes\\\", \\\"integrity\\\", \\\"media\\\", \\\"referrerpolicy\\\", \\\"rel\\\", \\\"sizes\\\", \\\"type\\\"]\\n};\\nfunction acceptDataAttrs(value) {\\n  const filtered = {};\\n  Object.keys(value || {}).filter((a) => a.startsWith(\\\"data-\\\")).forEach((a) => {\\n    filtered[a] = value[a];\\n  });\\n  return filtered;\\n}\\nfunction whitelistSafeInput(input) {\\n  const filtered = {};\\n  Object.keys(input).forEach((key) => {\\n    const tagValue = input[key];\\n    if (!tagValue)\\n      return;\\n    switch (key) {\\n      case \\\"title\\\":\\n      case \\\"titleTemplate\\\":\\n      case \\\"templateParams\\\":\\n        filtered[key] = tagValue;\\n        break;\\n      case \\\"htmlAttrs\\\":\\n      case \\\"bodyAttrs\\\":\\n        filtered[key] = acceptDataAttrs(tagValue);\\n        WhitelistAttributes[key].forEach((a) => {\\n          if (tagValue[a])\\n            filtered[key][a] = tagValue[a];\\n        });\\n        break;\\n      case \\\"meta\\\":\\n        if (Array.isArray(tagValue)) {\\n          filtered[key] = tagValue.map((meta) => {\\n            const safeMeta = acceptDataAttrs(meta);\\n            WhitelistAttributes.meta.forEach((key2) => {\\n              if (meta[key2])\\n                safeMeta[key2] = meta[key2];\\n            });\\n            return safeMeta;\\n          }).filter((meta) => Object.keys(meta).length > 0);\\n        }\\n        break;\\n      case \\\"link\\\":\\n        if (Array.isArray(tagValue)) {\\n          filtered[key] = tagValue.map((meta) => {\\n            const link = acceptDataAttrs(meta);\\n            WhitelistAttributes.link.forEach((key2) => {\\n              const val = meta[key2];\\n              if (key2 === \\\"rel\\\" && [\\\"stylesheet\\\", \\\"canonical\\\", \\\"modulepreload\\\", \\\"prerender\\\", \\\"preload\\\", \\\"prefetch\\\"].includes(val))\\n                return;\\n              if (key2 === \\\"href\\\") {\\n                if (val.includes(\\\"javascript:\\\") || val.includes(\\\"data:\\\"))\\n                  return;\\n                link[key2] = val;\\n              } else if (val) {\\n                link[key2] = val;\\n              }\\n            });\\n            return link;\\n          }).filter((link) => Object.keys(link).length > 1 && !!link.rel);\\n        }\\n        break;\\n      case \\\"noscript\\\":\\n        if (Array.isArray(tagValue)) {\\n          filtered[key] = tagValue.map((meta) => {\\n            const noscript = acceptDataAttrs(meta);\\n            WhitelistAttributes.noscript.forEach((key2) => {\\n              if (meta[key2])\\n                noscript[key2] = meta[key2];\\n            });\\n            return noscript;\\n          }).filter((meta) => Object.keys(meta).length > 0);\\n        }\\n        break;\\n      case \\\"script\\\":\\n        if (Array.isArray(tagValue)) {\\n          filtered[key] = tagValue.map((script) => {\\n            const safeScript = acceptDataAttrs(script);\\n            WhitelistAttributes.script.forEach((s) => {\\n              if (script[s]) {\\n                if (s === \\\"textContent\\\") {\\n                  try {\\n                    const jsonVal = typeof script[s] === \\\"string\\\" ? JSON.parse(script[s]) : script[s];\\n                    safeScript[s] = JSON.stringify(jsonVal, null, 0);\\n                  } catch (e) {\\n                  }\\n                } else {\\n                  safeScript[s] = script[s];\\n                }\\n              }\\n            });\\n            return safeScript;\\n          }).filter((meta) => Object.keys(meta).length > 0);\\n        }\\n        break;\\n    }\\n  });\\n  return filtered;\\n}\\n\\nasync function normaliseTag(tagName, input, e) {\\n  const tag = {\\n    tag: tagName,\\n    props: await normaliseProps(\\n      // explicitly check for an object\\n      // @ts-expect-error untyped\\n      typeof input === \\\"object\\\" && typeof input !== \\\"function\\\" && !(input instanceof Promise) ? { ...input } : { [[\\\"script\\\", \\\"noscript\\\", \\\"style\\\"].includes(tagName) ? \\\"innerHTML\\\" : \\\"textContent\\\"]: input },\\n      [\\\"templateParams\\\", \\\"titleTemplate\\\"].includes(tagName)\\n    )\\n  };\\n  TagConfigKeys.forEach((k) => {\\n    const val = typeof tag.props[k] !== \\\"undefined\\\" ? tag.props[k] : e[k];\\n    if (typeof val !== \\\"undefined\\\") {\\n      if (![\\\"innerHTML\\\", \\\"textContent\\\", \\\"children\\\"].includes(k) || TagsWithInnerContent.includes(tag.tag)) {\\n        tag[k === \\\"children\\\" ? \\\"innerHTML\\\" : k] = val;\\n      }\\n      delete tag.props[k];\\n    }\\n  });\\n  if (tag.props.body) {\\n    tag.tagPosition = \\\"bodyClose\\\";\\n    delete tag.props.body;\\n  }\\n  if (tag.tag === \\\"script\\\") {\\n    if (typeof tag.innerHTML === \\\"object\\\") {\\n      tag.innerHTML = JSON.stringify(tag.innerHTML);\\n      tag.props.type = tag.props.type || \\\"application/json\\\";\\n    }\\n  }\\n  return Array.isArray(tag.props.content) ? tag.props.content.map((v) => ({ ...tag, props: { ...tag.props, content: v } })) : tag;\\n}\\nfunction normaliseStyleClassProps(key, v) {\\n  const sep = key === \\\"class\\\" ? \\\" \\\" : \\\";\\\";\\n  if (typeof v === \\\"object\\\" && !Array.isArray(v)) {\\n    v = Object.entries(v).filter(([, v2]) => v2).map(([k, v2]) => key === \\\"style\\\" ? `${k}:${v2}` : k);\\n  }\\n  return (Array.isArray(v) ? v.join(sep) : v).split(sep).filter((c) => c.trim()).filter(Boolean).join(sep);\\n}\\nasync function normaliseProps(props, virtual) {\\n  for (const k of Object.keys(props)) {\\n    if ([\\\"class\\\", \\\"style\\\"].includes(k)) {\\n      props[k] = normaliseStyleClassProps(k, props[k]);\\n      continue;\\n    }\\n    if (props[k] instanceof Promise)\\n      props[k] = await props[k];\\n    if (!virtual && !TagConfigKeys.includes(k)) {\\n      const v = String(props[k]);\\n      const isDataKey = k.startsWith(\\\"data-\\\");\\n      if (v === \\\"true\\\" || v === \\\"\\\") {\\n        props[k] = isDataKey ? \\\"true\\\" : true;\\n      } else if (!props[k]) {\\n        if (isDataKey && v === \\\"false\\\")\\n          props[k] = \\\"false\\\";\\n        else\\n          delete props[k];\\n      }\\n    }\\n  }\\n  return props;\\n}\\nconst TagEntityBits = 10;\\nasync function normaliseEntryTags(e) {\\n  const tagPromises = [];\\n  Object.entries(e.resolvedInput).filter(([k, v]) => typeof v !== \\\"undefined\\\" && ValidHeadTags.includes(k)).forEach(([k, value]) => {\\n    const v = asArray$1(value);\\n    tagPromises.push(...v.map((props) => normaliseTag(k, props, e)).flat());\\n  });\\n  return (await Promise.all(tagPromises)).flat().filter(Boolean).map((t, i) => {\\n    t._e = e._i;\\n    e.mode && (t._m = e.mode);\\n    t._p = (e._i << TagEntityBits) + i;\\n    return t;\\n  });\\n}\\n\\nconst TAG_WEIGHTS = {\\n  // tags\\n  base: -10,\\n  title: 10\\n};\\nconst TAG_ALIASES = {\\n  // relative scores to their default values\\n  critical: -80,\\n  high: -10,\\n  low: 20\\n};\\nfunction tagWeight(tag) {\\n  let weight = 100;\\n  const priority = tag.tagPriority;\\n  if (typeof priority === \\\"number\\\")\\n    return priority;\\n  if (tag.tag === \\\"meta\\\") {\\n    if (tag.props[\\\"http-equiv\\\"] === \\\"content-security-policy\\\")\\n      weight = -30;\\n    if (tag.props.charset)\\n      weight = -20;\\n    if (tag.props.name === \\\"viewport\\\")\\n      weight = -15;\\n  } else if (tag.tag === \\\"link\\\" && tag.props.rel === \\\"preconnect\\\") {\\n    weight = 20;\\n  } else if (tag.tag in TAG_WEIGHTS) {\\n    weight = TAG_WEIGHTS[tag.tag];\\n  }\\n  if (typeof priority === \\\"string\\\" && priority in TAG_ALIASES) {\\n    return weight + TAG_ALIASES[priority];\\n  }\\n  return weight;\\n}\\nconst SortModifiers = [{ prefix: \\\"before:\\\", offset: -1 }, { prefix: \\\"after:\\\", offset: 1 }];\\n\\nconst NetworkEvents = [\\\"onload\\\", \\\"onerror\\\", \\\"onabort\\\", \\\"onprogress\\\", \\\"onloadstart\\\"];\\nconst ScriptNetworkEvents = [\\\"onload\\\", \\\"onerror\\\"];\\n\\nconst sepSub = \\\"%separator\\\";\\nfunction processTemplateParams(s, p, sep) {\\n  if (typeof s !== \\\"string\\\" || !s.includes(\\\"%\\\"))\\n    return s;\\n  function sub(token) {\\n    let val;\\n    if ([\\\"s\\\", \\\"pageTitle\\\"].includes(token)) {\\n      val = p.pageTitle;\\n    } else if (token.includes(\\\".\\\")) {\\n      val = token.split(\\\".\\\").reduce((acc, key) => acc ? acc[key] || void 0 : void 0, p);\\n    } else {\\n      val = p[token];\\n    }\\n    return typeof val !== \\\"undefined\\\" ? (val || \\\"\\\").replace(/\\\"/g, '\\\\\\\\\\\"') : false;\\n  }\\n  let decoded = s;\\n  try {\\n    decoded = decodeURI(s);\\n  } catch {\\n  }\\n  const tokens = (decoded.match(/%(\\\\w+\\\\.+\\\\w+)|%(\\\\w+)/g) || []).sort().reverse();\\n  tokens.forEach((token) => {\\n    const re = sub(token.slice(1));\\n    if (typeof re === \\\"string\\\") {\\n      s = s.replace(new RegExp(`\\\\\\\\${token}(\\\\\\\\W|$)`, \\\"g\\\"), (_, args) => `${re}${args}`).trim();\\n    }\\n  });\\n  if (s.includes(sepSub)) {\\n    if (s.endsWith(sepSub))\\n      s = s.slice(0, -sepSub.length).trim();\\n    if (s.startsWith(sepSub))\\n      s = s.slice(sepSub.length).trim();\\n    s = s.replace(new RegExp(`\\\\\\\\${sepSub}\\\\\\\\s*\\\\\\\\${sepSub}`, \\\"g\\\"), sepSub);\\n    s = processTemplateParams(s, { separator: sep }, sep);\\n  }\\n  return s;\\n}\\n\\nexport { HasElementTags, IsBrowser, NetworkEvents, ScriptNetworkEvents, SelfClosingTags, SortModifiers, TAG_ALIASES, TAG_WEIGHTS, TagConfigKeys, TagEntityBits, TagsWithInnerContent, UniqueTags, ValidHeadTags, asArray$1 as asArray, composableNames, defineHeadPlugin, hashCode, hashTag, normaliseEntryTags, normaliseProps, normaliseStyleClassProps, normaliseTag, packMeta, processTemplateParams, resolveMetaKeyType, resolveMetaKeyValue, resolvePackedMetaObjectValue, resolveTitleTemplate, tagDedupeKey, tagWeight, unpackMeta, whitelistSafeInput };\\n\"],\n  \"mappings\": \"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\",\n  \"names\": [\"k\", \"k2\", \"p\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1712518294223,
      "end": 1712518294223,
      "order": "normal"
    }
  ]
}
